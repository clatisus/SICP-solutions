# -*- org-export-babel-evaluate: nil -*-
#+TITLE: Solutions
#+PROPERTY: header-args:racket  :lang sicp :exports both
#+PROPERTY: header-args:racket+ :tangle (concat (nth 4 (org-heading-components)) ".rkt")

* Procedures
:PROPERTIES:
:header-args:racket: :tangle no :export none :eval never
:END:
** gcd
#+name: gcd
#+begin_src racket
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+end_src
** sqrt
#+name: sqrt
#+begin_src racket
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
#+end_src

#+RESULTS: sqrt

*** average-damp
#+name: average-damp
#+begin_src racket
(define (average-damp f)
  (lambda (x) (/ (+ (f x)
                    x)
                 2)))
#+end_src

** fixed-point
#+name: fixed-point
#+begin_src racket
(define (fixed-point f first-guess)
  (define tolerance 0.00001)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

#+end_src
** square
#+name: square
#+begin_src racket
(define (square x) (* x x))
#+end_src

* 2.01
In =(let*)= you can use previously defined local variable.

One argument =(-)= is =(lambda (x) (* -1 x)=
One argument =(+)= is =(lambda (x) (* 1 x)=
#+begin_src racket :noweb yes
<<gcd>>
<<rat>>
(define (make-rat n d)
  (let* ((neg ((if negative? d) - +))
         (n (abs n))
         (d (abs d))
         (g (gcd n d)))
    (cons (neg (/ n g))
          (/ d g))))
#+end_src
* 2.02
Point procedures
#+name: point
#+begin_src racket
(define (average x y) (/ (+ x y) 2))

(define (make-point x y)
  (cons x y))

(define (x-point p)
  (car p))

(define (y-point p)
  (cdr p))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
#+end_src

Segment procedures

#+name: segment
#+begin_src racket
(define (make-segment p1 p2)
  (cons p1 p2))

(define (start-segment p)
  (car p))

(define (end-segment p)
  (cdr p))

(define (midpoint-segment s)
  (make-point
   (average (x-point (start-segment s))
            (x-point (end-segment s)))
   (average (y-point (start-segment s))
            (y-point (end-segment s)))))
#+end_src

#+begin_src racket :noweb eval
<<point>>
<<segment>>
(define p1 (make-point 0 0))
(define p2 (make-point 10 10))

(define s (make-segment p1 p2))

(print-point (midpoint-segment s))
#+end_src

#+RESULTS:
:
: (5,5)

* 2.03
#+name: method-1
#+begin_src racket :noweb eval
<<point>>
<<segment>>
<<compose>>
<<square>>

(define (make-rect p1 p2 p3 p4)
  ;; p1 ----seg1----- p2
  ;;  |               |
  ;;  s               s
  ;;  e               e
  ;;  g               g
  ;;  3               4
  ;;  |               |
  ;; p3 ----seg2----- p4
  (cons (cons p1 p2)
        (cons p3 p4)))

(define (p1-rect r)
 (car (car r)))

(define (p2-rect r)
 (cdr (car r)))

(define (p3-rect r)
 (car (cdr r)))

(define (p4-rect r)
 (cdr (car r)))

(define (h-rect r)
  (distance (p1-rect r)
            (p3-rect r)))
(define (w-rect r)
  (distance (p1-rect r)
            (p2-rect r)))

(define (distance p1 p2)
  (sqrt
   (+ (square
       (- (x-point p1 ) (x-point p2)))
      (square
       (- (y-point p1 ) (y-point p2))))))

(define (perimiter-rect r)
  (* 2
     (+ (h-rect r)
        (w-rect r))))

(define (area-rect r)
  (* (h-rect r)
     (w-rect r)))
#+end_src

#+begin_src racket :noweb eval
<<method-1>>
(define p1 (make-point 0 4))
(define p2 (make-point 3 4))
(define p3 (make-point 0 0))
(define p4 (make-point 3 0))

(define r (make-rect p1 p2 p3 p4))

(perimiter-rect r)
(area-rect r)
r
#+end_src

#+RESULTS:
: 14
: 12

#+name: method-2
#+begin_src racket :noweb eval
<<point>>
<<segment>>
<<compose>>
<<square>>

(define (make-rect lb h w) ;; left-botton height widht
  (cons lb
        (cons h w)))

(define (h-rect r)
  (car (cdr r)))
(define (w-rect r)
  (cdr (cdr r)))

(define (perimiter-rect r)
  (* 2
     (+ (h-rect r)
        (w-rect r))))

(define (area-rect r)
  (* (h-rect r)
     (w-rect r)))
#+end_src

#+begin_src racket :noweb eval
<<method-2>>
(define p1 (make-point 0 0))
(define r (make-rect p1 4 3))

(perimiter-rect r)
(area-rect r)
#+end_src

#+RESULTS:
: 14
: 12
* 2.04
#+begin_src racket
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))

(car (cons 1 2))
#+end_src

#+RESULTS:
: 1

=(cons)= returns a procedure which takes one argument and applies other arguments as its
operand.

=(car)= Takes a [procedure] as argument and applies it to a lambda which returns its first argument.

#+begin_src racket :tangle no :eval no
(car (cons 1 2))
(car (lambda (m) (m 1 2)))
((lambda (m) (m 1 2) (lambda (p q) p)))
((lambda (p q) p) 1 2)
1
#+end_src

cdr
#+begin_src racket
(define (cons x y)
  (lambda (m) (m x y)))
(define (cdr z)
  (z (lambda (p q) q)))

(cdr (cons 1 2))
#+end_src

#+RESULTS:
: 2
* 2.05
#+begin_src racket
(define (cons a b)
  (* (expt 2 a)
     (expt b)))

(define (count base num)
  (if (= (remainder num base) 0)
      (+ 1 (count base(/ num base)))
      0))

(define (car p)
  (count 2 p))

(define (cdr p)
  (count 3 p))

(car (cons 5 9))
(cdr (cons 5 9))
#+end_src

#+RESULTS:
: 5
: 9
* TODO 2.06
I don't want to feel idiot about lambda calculus now.
I want to go through SICP.
TODO When I start lambda calculus solve this.
* 2.07
#+name: interval
#+begin_src racket
(define (make-interval a b) (cons a b))

(define (lower-bound i) (car i))
(define (upper-bound i) (cdr i))
#+end_src
* 2.08
#+begin_src racket :noweb no-export
<<interval>>
(define (sub-interval a b)
  (make-interval
   (- (lower-bound a) (lower-bound b))
   (- (upper-bound a) (upper-bound b))))
#+end_src
* 2.09
#+name: mul
#+begin_src racket :tangle no :eval no
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
#+end_src

#+name: add
#+begin_src racket :tangle no :eval no
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
#+end_src

In =(add-interval)= and =(sub-interval)= width of interval can be good parameter for finding new intervals width.
#+begin_src racket :noweb no-export
<<interval>>
<<mul>>
<<add>>

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define i1 (make-interval 10 20))
(define i2 (make-interval 30 50))

(width i1)
(width i2)
(width (add-interval i1 i2))
#+end_src

#+RESULTS:
: 5
: 10
: 15

But in =(mul-interval)= and =(div-interval)= something changes.
Functions must be give same output for same input.
If our input source don't contain enough, that operatoin won't be a =function=.
For example

Width of =(make-interval 0 10)= is 10 also width of =(make-interval 100 110)= is 10.
If we can create function like $f(w_1, w_2) = w_3$  $w_3$ should not differ with same inputs.
#+begin_src racket :noweb eval
<<interval>>
<<mul>>

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define i1 (make-interval 0 10))
(define i2 (make-interval 100 110))

(width i1)
(width i2)
(width (mul-interval i1 (make-interval 5 10)))
(width (mul-interval i2 (make-interval 5 10)))
#+end_src

#+RESULTS:
: 5
: 5
: 50
: 300
* 2.10
#+begin_src racket :noweb no-export
<<interval>>
<<mul>>

(define (div-interval x y)
  (if (or (zero? (upper-bound y))
          (zero? (lower-bound y)))
      (error "(div-interval x y) Y can't be 0")
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))

(div-interval (make-interval 10 20) (make-interval 0 10))
#+end_src

#+RESULTS:
: Errrrr
* TODO 2.11
These are the 9 conditions
Left ones have 1 2 right ones have a b

TODO Will add third column

| Interval 1 | Interval 2 |
| (+ . +)    | (+ . +)    |
|            |            |
| (- . -)    | (- . -)    |
|            |            |
| (- . -)    | (+ . +)    |
| (+ . +)    | (- . -)    |
|            |            |
| (- . +)    | (+ . +)    |
| (+ . +)    | (- . +)    |
|            |            |
| (- . +)    | (- . -)    |
| (- . -)    | (- . +)    |
|            |            |
| (- . +)    | (- . +)    |

Only last one needs more than 2 multiplication.

This will be very ugly If I wrote this with my narrow FP and DSL knowledge.
Lots of and , or ...
TODO When I learn pattern matching, simple macros etc will beauty up this.

#+begin_src racket :noweb eval :eval no :tangle no
<<interval>>

(define (I p1 p2))

(define (mul-interval a b)
  ((cond
     ((I ++ ++ a b) ....)
   )
  )
#+end_src
