# -*- org-export-babel-evaluate: nil -*-
#+TITLE: Solutions
#+PROPERTY: header-args:racket  :lang sicp :exports both
#+PROPERTY: header-args:racket+ :tangle (concat (nth 4 (org-heading-components)) ".rkt")
#+PROPERTY: header-args:racket+ :noweb no-export

* Procedures
:PROPERTIES:
:header-args:racket: :tangle no :export none :eval never
:END:
** gcd
#+name: gcd
#+begin_src racket
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+end_src
** sqrt
#+name: sqrt
#+begin_src racket
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
#+end_src

#+RESULTS: sqrt

*** average-damp
#+name: average-damp
#+begin_src racket
(define (average-damp f)
  (lambda (x) (/ (+ (f x)
                    x)
                 2)))
#+end_src

** fixed-point
#+name: fixed-point
#+begin_src racket
(define (fixed-point f first-guess)
  (define tolerance 0.00001)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

#+end_src
** square
#+name: square
#+begin_src racket
(define (square x) (* x x))
#+end_src

* 2.01
In =(let*)= you can use previously defined local variable.

One argument =(-)= is =(lambda (x) (* -1 x)=
One argument =(+)= is =(lambda (x) (* 1 x)=
#+begin_src racket :noweb yes
<<gcd>>
<<rat>>
(define (make-rat n d)
  (let* ((neg ((if negative? d) - +))
         (n (abs n))
         (d (abs d))
         (g (gcd n d)))
    (cons (neg (/ n g))
          (/ d g))))
#+end_src
* 2.02
Point procedures
#+name: point
#+begin_src racket
(define (average x y) (/ (+ x y) 2))

(define (make-point x y)
  (cons x y))

(define (x-point p)
  (car p))

(define (y-point p)
  (cdr p))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
#+end_src

Segment procedures

#+name: segment
#+begin_src racket
(define (make-segment p1 p2)
  (cons p1 p2))

(define (start-segment p)
  (car p))

(define (end-segment p)
  (cdr p))

(define (midpoint-segment s)
  (make-point
   (average (x-point (start-segment s))
            (x-point (end-segment s)))
   (average (y-point (start-segment s))
            (y-point (end-segment s)))))
#+end_src

#+begin_src racket :noweb eval
<<point>>
<<segment>>
(define p1 (make-point 0 0))
(define p2 (make-point 10 10))

(define s (make-segment p1 p2))

(print-point (midpoint-segment s))
#+end_src

#+RESULTS:
:
: (5,5)

* 2.03
#+name: method-1
#+begin_src racket :noweb eval
<<point>>
<<segment>>
<<compose>>
<<square>>

(define (make-rect p1 p2 p3 p4)
  ;; p1 ----seg1----- p2
  ;;  |               |
  ;;  s               s
  ;;  e               e
  ;;  g               g
  ;;  3               4
  ;;  |               |
  ;; p3 ----seg2----- p4
  (cons (cons p1 p2)
        (cons p3 p4)))

(define (p1-rect r)
  (car (car r)))

(define (p2-rect r)
  (cdr (car r)))

(define (p3-rect r)
  (car (cdr r)))

(define (p4-rect r)
  (cdr (car r)))

(define (h-rect r)
  (distance (p1-rect r)
            (p3-rect r)))
(define (w-rect r)
  (distance (p1-rect r)
            (p2-rect r)))

(define (distance p1 p2)
  (sqrt
   (+ (square
       (- (x-point p1 ) (x-point p2)))
      (square
       (- (y-point p1 ) (y-point p2))))))

(define (perimiter-rect r)
  (* 2
     (+ (h-rect r)
        (w-rect r))))

(define (area-rect r)
  (* (h-rect r)
     (w-rect r)))
#+end_src

#+begin_src racket :noweb eval
<<method-1>>
(define p1 (make-point 0 4))
(define p2 (make-point 3 4))
(define p3 (make-point 0 0))
(define p4 (make-point 3 0))

(define r (make-rect p1 p2 p3 p4))

(perimiter-rect r)
(area-rect r)
r
#+end_src

#+RESULTS:
: 14
: 12

#+name: method-2
#+begin_src racket :noweb eval
<<point>>
<<segment>>
<<compose>>
<<square>>

(define (make-rect lb h w) ;; left-botton height widht
  (cons lb
        (cons h w)))

(define (h-rect r)
  (car (cdr r)))
(define (w-rect r)
  (cdr (cdr r)))

(define (perimiter-rect r)
  (* 2
     (+ (h-rect r)
        (w-rect r))))

(define (area-rect r)
  (* (h-rect r)
     (w-rect r)))
#+end_src

#+begin_src racket :noweb eval
<<method-2>>
(define p1 (make-point 0 0))
(define r (make-rect p1 4 3))

(perimiter-rect r)
(area-rect r)
#+end_src

#+RESULTS:
: 14
: 12
* 2.04
#+begin_src racket
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))

(car (cons 1 2))
#+end_src

#+RESULTS:
: 1

=(cons)= returns a procedure which takes one argument and applies other arguments as its
operand.

=(car)= Takes a [procedure] as argument and applies it to a lambda which returns its first argument.

#+begin_src racket :tangle no :eval no
(car (cons 1 2))
(car (lambda (m) (m 1 2)))
((lambda (m) (m 1 2) (lambda (p q) p)))
((lambda (p q) p) 1 2)
1
#+end_src

cdr
#+begin_src racket
(define (cons x y)
  (lambda (m) (m x y)))
(define (cdr z)
  (z (lambda (p q) q)))

(cdr (cons 1 2))
#+end_src

#+RESULTS:
: 2
* 2.05
#+begin_src racket
(define (cons a b)
  (* (expt 2 a)
     (expt b)))

(define (count base num)
  (if (= (remainder num base) 0)
      (+ 1 (count base(/ num base)))
      0))

(define (car p)
  (count 2 p))

(define (cdr p)
  (count 3 p))

(car (cons 5 9))
(cdr (cons 5 9))
#+end_src

#+RESULTS:
: 5
: 9
* TODO 2.06
I don't want to feel idiot about lambda calculus now.
I want to go through SICP.
TODO When I start lambda calculus solve this.
* 2.07
#+name: interval
#+begin_src racket
(define (make-interval a b) (cons a b))

(define (lower-bound i) (car i))
(define (upper-bound i) (cdr i))
#+end_src
* 2.08
#+begin_src racket :noweb no-export
<<interval>>
(define (sub-interval a b)
  (make-interval
   (- (lower-bound a) (lower-bound b))
   (- (upper-bound a) (upper-bound b))))
#+end_src
* 2.09
#+name: mul
#+begin_src racket :tangle no :eval no
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
#+end_src

#+name: add
#+begin_src racket :tangle no :eval no
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
#+end_src

In =(add-interval)= and =(sub-interval)= width of interval can be good parameter for finding new intervals width.
#+begin_src racket :noweb no-export
<<interval>>
<<mul>>
<<add>>

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define i1 (make-interval 10 20))
(define i2 (make-interval 30 50))

(width i1)
(width i2)
(width (add-interval i1 i2))
#+end_src

#+RESULTS:
: 5
: 10
: 15

But in =(mul-interval)= and =(div-interval)= something changes.
Functions must be give same output for same input.
If our input source don't contain enough, that operation won't be a =function=.
For example

Width of =(make-interval 0 10)= is 10 also width of =(make-interval 100 110)= is 10.
If we can create function like $f(w_1, w_2) = w_3$  $w_3$ should not differ with same inputs.
#+begin_src racket :noweb eval
<<interval>>
<<mul>>

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define i1 (make-interval 0 10))
(define i2 (make-interval 100 110))

(width i1)
(width i2)
(width (mul-interval i1 (make-interval 5 10)))
(width (mul-interval i2 (make-interval 5 10)))
#+end_src

#+RESULTS:
: 5
: 5
: 50
: 300
* 2.10
#+begin_src racket :noweb no-export
<<interval>>
<<mul>>

(define (div-interval x y)
  (if (or (zero? (upper-bound y))
          (zero? (lower-bound y)))
      (error "(div-interval x y) Y can't be 0")
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))

(div-interval (make-interval 10 20) (make-interval 0 10))
#+end_src

#+RESULTS:
: Errrrr
* TODO 2.11
These are the 9 conditions
Left ones have 1 2 right ones have a b

TODO Will add third column

| Interval 1 | Interval 2 |
| (+ . +)    | (+ . +)    |
|            |            |
| (- . -)    | (- . -)    |
|            |            |
| (- . -)    | (+ . +)    |
| (+ . +)    | (- . -)    |
|            |            |
| (- . +)    | (+ . +)    |
| (+ . +)    | (- . +)    |
|            |            |
| (- . +)    | (- . -)    |
| (- . -)    | (- . +)    |
|            |            |
| (- . +)    | (- . +)    |

Only last one needs more than 2 multiplication.

This will be very ugly If I wrote this with my narrow FP and DSL knowledge.
Lots of and , or ...
TODO When I learn pattern matching, simple macros etc will beauty up this.

#+begin_src racket :noweb eval :eval no :tangle no
<<interval>>

(define (I p1 p2))

(define (mul-interval a b)
  ((cond
     ((I ++ ++ a b) ....)
     )
   )
#+end_src
* 2.12
#+name: center
#+begin_src racket :noweb no-export
<<interval>>
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (make-center-percent c p)
  (make-interval (- c (/ (* c p) 100))
                 (+ c (/ (* c p) 100))))
(define (percent i)
  (/  (* 100 (width i)) (center i)))
#+end_src
* 2.13
To find something writing down equations.
We know that $p_1$ and $p_2$ are small.
To find lower bound of interval.
I  think we can say that (in very small numbers)
\[\frac{c_1(100-p_1)}{100} \frac{c_2(100-p_2)}{100} \approx \frac{c_1c_2(10^4 - 100(p_1 + p_2) +p_1p_2)}{10^4}\]

$p_1p_2$ is multiplication of two small numbers to we can ignore it.

\[\frac{c_1c_2(10^2 -(p_1 + p_2))}{10^2}\]
Percent is $(1 -\frac{p_1 + p_2}{100}))$

We are talking about the little one. How much far from center.
So Percent is $p_1 + p_2$

#+begin_src racket :noweb no-export
<<center>>
<<mul>>


(percent (mul-interval (make-center-percent 10000 0.001)
                       (make-center-percent 10000 0.001)))
(+ 0.001 0.001)

(percent (mul-interval (make-center-percent 100000000 0.00001)
                       (make-center-percent 100000000 0.00001)))
(+ 0.00001 0.00001)
#+end_src

#+RESULTS:
: 0.001999999999807451
: 0.002
: 1.99999999999998e-05
: 2e-05

* 2.14
Trying to satisfy Lem E. Tweakit

#+name: div
#+begin_src racket :tangle no :eval no
(define (div-interval x y)
  (if (or (zero? (upper-bound y))
          (zero? (lower-bound y)))
      (error "(div-interval x y) Y can't be 0")
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))
#+end_src

They're really different
#+begin_src racket :noweb no-export
<<center>>
<<add>>
<<mul>>
<<div>>
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))

(define r1 (make-interval 10 20))
(define r2 (make-interval 10 20))

(par1 r1 r2)
(par2 r1 r2)
#+end_src

#+RESULTS:
: (2.5 . 20.0)
: (5.0 . 10.0)

With pen and paper it can be seen that =(par2)= gives true output.

#+name: p1
#+begin_src racket :noweb eval
<<center>>
<<add>>
<<mul>>
<<div>>
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define r1 (make-interval 10 20))
(define r2 (make-interval 10 20))

(par1 r1 r2) ;; 2.5 Wrong

(mul-interval r1 r2) ;; 100 True

(add-interval r1 r2);; 20 True

(div-interval ;; Should be 5 but 2.5
 (mul-interval r1 r2)
 (add-interval r1 r2))

;; (define (div-interval x y)
;;   (if (or (zero? (upper-bound y))
;;           (zero? (lower-bound y)))
;;       (error "(div-interval x y) Y can't be 0")
;;       (mul-interval
;;        x
;;        (make-interval (/ 1.0 (upper-bound y))
;;                       (/ 1.0 (lower-bound y))))))

(mul-interval (make-interval 100 400)
              (make-interval
               (/ 1.0 40)
               (/ 1.0 20)))

(* 100 (/ 1.0 40)) ;; This is the prolem
#+end_src
#+RESULTS:
: (2.5 . 20.0)
: (100 . 400)
: (20 . 40)
: (2.5 . 20.0)
: (2.5 . 20.0)
: 0.025
: 0.05

Because bound are changed in =(mul-divide)= values are changed too.
* 2.17
#+begin_src racket
(define (last-pair elements)
  (if (null? (cdr elements))
      elements
      (last-pair (cdr elements))))

(last-pair (list 1 2 3 4 5))
#+end_src

#+RESULTS:
: (5)
* 2.18
Iterative way

#+begin_src racket
(define (reverse elements)
  (define (iter l result)
    (if (null? l)
        result
        (iter (cdr l) (cons (car l) result))))
  (iter elements (list )))

(reverse (list 1 2 3))
#+end_src

#+RESULTS:
: (3 2 1)

Recursive way

This is wrong
#+begin_src racket :tangle no :eval no
(define (reverse l)
  (if (null? (cdr l))
      l
      (append (reverse (cdr l))
              (car l))))

(reverse (list 1 2 3))
#+end_src

Because it expands like this last. Can see the problem in last line.

#+begin_src racket :tangle no :eval no
(append (reverse (list 2 3)) 1)
(append (append (reverse (list  3)) 2) 1)
(append (append (list 3) 2) 1)
(append (append (list 3) 2) 1)
#+end_src

When you append a atom to a a list it becomes pair because only difference between a pair and a list is
lists have =nil= at the end.
And you can =(append)= more to that pair because it'll never have =nil=.

#+begin_src racket :tangle no
(append (list 1 2 3) 2)
#+end_src

#+RESULTS:
: (1 2 3 . 2)

But that reverse will work for two pair because you don't need to =(append)= more.
#+begin_src racket
(define (reverse l)
  (if (null? (cdr l))
      l
      (append (reverse (cdr l))
              (car l))))

(reverse (list 1 2))
#+end_src

#+RESULTS:
: (2 . 1)

For solution you need to =(append)= a list not an atom.
#+begin_src racket
(define (reverse l)
  (if (null? (cdr l))
      l
      (append (reverse (cdr l))
              (list (car l)))))

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

In this
#+begin_src racket :tangle no :eval no
(append (reverse (list 2 3)) (list 1))
(append (append (reverse (list 3)) (list 2)) (list 1))
(append (append (list 3) (list 2)) (list 1))
(append (list 3 2) (list 1))
(append (list 3 2 1))
#+end_src

Difference between =(cons)= with this way you are creating same level pairs(lists).
So it won't nest up.
* 2.19
Order of coins should not effect result because tree will expand for every possible way.
#+begin_src racket
(define (cc amount coin-values)
  (define (no-more? l) (null? l))
  (define (except-first-denomination l) (cdr l))
  (define (first-denomination l) (car l))
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))

(define us-coins (list 50 25 10 5 1))
(define fake-us-coins (list 1 10 25 5 50))

(cc 100 us-coins)
(cc 100 fake-us-coins)
#+end_src

#+RESULTS:
: 292
: 292
: 104561
* TODO 2.20
Iterative way
#+begin_src racket
(define (same-parity base . l)
  (define (mod2 x) (remainder x 2))
  (define (iter l acc)
    (if (null? l)
        acc
        (iter (cdr l)
              (if (= (mod2 base) (mod2 (car l)))
                  (append acc (list (car l)))
                  acc))))
  (iter l (list base)))
#+end_src

Recursive way

#+begin_src racket
(define (same-parity base . l)
  (define (same? x)
    (= (remainder base 2)
       (remainder x 2)))

  (define (iter l)
    (if (null? (cdr l)) ;; Saved 1 call with cdr :)))
        l
        (append (if (same? (car l))
                    (list (car l))
                    (list))
                (iter (cdr l)))))
  (cons base (iter l)))
(same-parity 1 2 3 4 5 6 7)
#+end_src

#+RESULTS:
: (1 3 5 7)

This solution relies on the fact that you can append empty list without problem.

#+begin_src racket
(list 1 2 3 (list) 4 5 6)
(append (list 1 2 3) (list) (list 4 5 6))
#+end_src

#+RESULTS:
: (1 2 3 () 4 5 6)
: (1 2 3 4 5 6)

But using append is not very good for time complexity one should try to prepend with =(cons)= and =(reverse)= at the end.
But I don't know how to flatten the list so it's TODO.

* 2.21
#+name: sq
#+begin_src racket :tangle no :eval no
(define (square x) (* x x))
#+end_src

#+begin_src racket :noweb no-export
<<sq>>
(define (square-list items)
  (if (null? items)
      (list)
      (cons
       (square (car items)) (square-list (cdr items)))))


(define (square-list items)
  (map square items))

(square-list (list 1 2 3 4))
#+end_src
* 2.22
Problem is =answer= has the previous values why it's on right side.
#+begin_src racket :noweb no-export
<<sq>>
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))

(square-list (list 1 2 3))
#+end_src

#+RESULTS:
: (9 4 1)

In first =(cons)= problem can seen. It evaluates this =(cons nil 1)=.
In second =(cons)= it evaluates =(cons (cons nil 1) 4)=
It nests up to handle this, can use =(append)=.
#+begin_src racket :noweb eval
<<sq>>
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))

(square-list (list 1 2 3))
#+end_src

#+RESULTS:
: (((() . 1) . 4) . 9)
* 2.23
#+begin_src racket
(define (for-each f l)
  (cond ((null? l) #t)
        (else
         (f (car l))
         (for-each f (cdr l)))))
#+end_src
* 2.24
#+begin_src racket :lang racket
(require sdraw)
(define (draw t) (sdraw t #:null-style '/))
(draw (list 1 (list 2 (list 3 4))))
#+end_src
* 2.25
[[https://stackoverflow.com/questions/67680068/shorthand-for-car-and-cdr][Scheme provides car/cdr combinations up to 4 step]]
=l3= is a good example that shows =cdr= points whole pair not the first element of pair.
=car= of =cdr= points first element in pair.

#+begin_src racket
(define l1 (list 1 3 (list 5 7) 9))
(define l2 (list (list 7)))
(define l3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
(car (cdaddr l1))
(caar l2)
(cadadr (cadadr (cadadr l3)))
#+end_src

#+RESULTS:
: 7
: 7
: 7
* 2.26
#+begin_src racket
(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y)
(cons x y)
(list x y)
#+end_src

#+RESULTS:
: (1 2 3 4 5 6)
: ((1 2 3) 4 5 6)
: ((1 2 3) (4 5 6))
* 2.27
Iterative way

Generally iterative way is good for reverse operations.
Because we can use =(cons)= (it's =\theta(n)= ).

#+begin_src racket
(define (deep-reverse l)
  (define (iter cur r)
    (if (null? cur)
        r
        (iter
         (cdr cur)
         (cons (if (pair? (car cur))
                   (deep-reverse (car cur))
                   (car cur))
               r))))
  (iter l (list)))

(deep-reverse (list (list 1 2) (list 3 4)))
#+end_src
Recursive way

Key point is when you =(append)= two list they lose their level and become one.
If you don't want this just wrap =cdr= one with =(list)=
And you can't take =(cdr)= or =(car)= of an atom so handle that.

#+begin_src racket
(define (deep-reverse l)
  (cond ((null? l) nil)
        ((not (pair? l)) l)
        (else
         (append
          (deep-reverse (cdr l))
          (list (deep-reverse (car l)))))))
#+end_src

Found this [[http://community.schemewiki.org/?sicp-ex-2.27][on internet]]
Very good solution *for only list of lists*.

#+begin_src racket
(define (deep-reverse l)
  (reverse (map reverse l)))

#+end_src

Found this [[http://community.schemewiki.org/?sicp-ex-2.27][on the same site]]
Very good solution.

#+begin_src racket
(define (deep-reverse t)
  (if (pair? t)
      (reverse (map deep-reverse t))
      t))
#+end_src

* 2.28
=((null? l) l)= is necessary because we need to wrap non atoms with =(list)=.
We need because if you don't wrap with  =(list)= you'll end up with pair =( 1 2 3 4 . 5)= or error
because you can't =(append 1 (list 2 3))= use =append= like this.

A little advice always write and think inductive part first.
Then you'll see what edge cases you'll have.

#+begin_src racket
(define (fringe l)
  (cond
    ((null? l) l)
    ((not (pair? l)) (list l))
    (else
     (append (fringe (car l))
             (fringe (cdr l))))))

(define l (list (list 1 2) (list 3 4)))
(fringe l)
#+end_src

#+RESULTS:
: (1 2 3 4)
* 2.29
[[https://en.wikipedia.org/wiki/Mobile_(sculpture)][Mobile]] is a type of sculpture.

#+name: makes
#+begin_src racket
(define (make-mobile left right) ;; left-branch and right-branch
  (list left right))

(define (make-branch length structure)
  (list length structure))
#+end_src

a

#+name: sels
#+begin_src racket
(define (left-branch mobile)
  (car mobile))

(define (right-branch mobile)
  (cadr mobile))

(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cadr branch))
#+end_src

b

This part took a lot of time for me because I crated wrong =mobile= in =(make-mobile)=.
Be careful about that. While creating an object always think what =constructor= means

Again first think inductive step. Then think it's edge cases, (base cases).

#+name: wei
#+begin_src racket :noweb eval
<<makes>>
<<sels>>
(define (total-weight m)
  (cond ((null? m) 0)
        ((not (pair? m)) m)
        (else
         (+ (total-weight (branch-structure (left-branch m)))
            (total-weight (branch-structure (right-branch m)))))))
#+end_src

c

Question said
#+begin_quote
Design a predicate that tests whether a binary mobile is balanced.
#+end_quote

That's why =(balanced?)= has =?= at the end. It's scheme's convention.

#+begin_src racket :noweb eval
<<wei>>
(define (balanced? m)
  (cond
    ((null? m) #t)
    ((not (pair? m)) #t) ;; No need to look a weight's left, right branches and its children because
    ;; There are none
    (else
     (and (= (torque (left-branch m))
             (torque (right-branch m)))
          (balanced? (branch-structure (left-branch m)))
          (balanced? (branch-structure (right-branch m)))))))

(define (torque b)
  (* (branch-length b) (total-weight (branch-structure b))))
#+end_src

d

I think =(cons)= is better representation since mobile is binary.
We are only changing selector which contains =(cadr)= to =(cdr)=.
#+begin_src racket
(define (right-branch mobile)
  (cdr mobile))
(define (branch-structure branch)
  (cdr branch))
#+end_src

#+RESULTS:
: 21
* 2.30
Without =(map)=
#+begin_src racket :noweb eval
<<sq>>
(define (square-tree t)
  (cond
    ((null? t) t)
    ((not (pair? t)) (square t))
    (else
     (cons (square-tree (car t))
        (square-tree (cdr t))))))
#+end_src

With =(map)=
#+begin_src racket :noweb eval
<<sq>>
(define (square-tree t)
  (map (lambda (sub-t)
         (if (pair? sub-t)
             (square-tree sub-t)
             (square sub-t)))
       t))
(square-tree (list 1 2 (list 3 4)))
#+end_src
* 2.31
#+begin_src racket :noweb eval
<<sq>>
(define (treemap fn t)
  (map (lambda (sub-t)
         (if (pair? sub-t)
             (treemap fn sub-t)
             (fn sub-t))
         ) t))

(define (square-tree t)
  (treemap square t))

(square-tree (list (list 1 2) (list 3 4) 5))
#+end_src

#+RESULTS:
: ((1 4) (9 16) 25)
* 2.32
Subset of =(1 2 3)= is subset of =(2 3)= and =1= inserted into subset of =(2 3)= pattern is this.

#+begin_src racket
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest
                (map (lambda (x)
                       (cons (car s) x))
                     rest)))))
(subsets (list 1 2 3))
#+end_src
* 2.33
This exercise was mind blowing.
Not because of its hardness it shows the face that =(accumulate)= generalizes everything.
And code works! There is too little to write I don't make mistake.

#+name: acc
#+begin_src racket :tangle no :eval no
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
#+end_src

#+begin_src racket :noweb eval
<<acc>>
(define (map p sequence)
  (accumulate (lambda (x y)
                (cons (p x) y))
              nil sequence))

(define (append seq1 seq2)
  (accumulate cons
              seq2 seq1))

(define (length sequence)
  (accumulate
   (lambda (x y) (inc y))
   0 sequence))
#+end_src
* 2.34
#+begin_src racket :noweb eval
<<acc>>
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms-coeffs)
                (+ this-coeff
                   (* x higher-terms-coeffs)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
#+end_src

#+RESULTS:
: 79
* 2.35
#+begin_src racket :noweb eval
<<acc>>
(define (count-leaves t)
  (accumulate + 0
              (map (lambda (x)
                     (cond
                       ((null? x) 0)
                       ((pair? x) (count-leaves x))
                       (else 1)))
                   t)))

(count-leaves (list (list 1 (list 2 3)) (list 4 5)))
#+end_src

#+RESULTS:
: 5
* 2.36
=(map)= can take more than one sequence as argument.

#+name: accn
#+begin_src racket :noweb eval
<<acc>>
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init
                        (map car seqs))
            (accumulate-n op init
                          (map cdr seqs)))))
#+end_src

#+begin_src racket :noweb eval
<<accn>>
(define l (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(accumulate-n + 0 l)
#+end_src


#+RESULTS:
: (22 26 30)

Until now always used map for computing something, but with =(car)=, =(map)= showed it potential for me.

Also notice that =(map cdr seqs)= actually does =(cadr)= because it'll evaluate =(car)= in upper call.

#+begin_quote
But I started to worry about efficency from internet I learned I should don't care about efficency until book say.
#+end_quote

I said this in previous commit I didn't amend it because I think this is good case for writing
Because we are dealing with linked lists I always think another \theta(n) complexity etc.
But in this example we are trimming down the list so every list operation is \theta(1) because =(car)=.
And I hope =(cdr)= is taken from enviroment...

I'll quote upper paragraph too when I have answer.
* 2.37
Books says that
#+begin_quote
Which are described in any book on matrix algebra
#+end_quote

So I assume that these are normal matrix multiplication.
If not, there will be problem with the fact that for matrix multiplication
first element's column's number must be same with second element's row's number.

#+name: rand-data
#+begin_src racket :tangle no :eval no
(define v1 (list 1 2 3))
(define v2 (list 4 5 6))

(define m1
  (list (list 1 2 3)
        (list 4 5 6)
        (list 7 8 9)))

(define m2
  (list (list 1 2 3)
        (list 4 5 6)
        (list 0 0 0)))
#+end_src

#+name: dot
#+begin_src racket :tangle no :eval no :noweb eval
<<accn>>
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
#+end_src

Actually you can multiply if column number of first element is not equal to row number of second element.
But if first one's column is larger then larger parts won't be in equation.
If second one's row's are larger then larger parts won't be in equation.

TODO I will find why this is Like that I searched a little but couldn't find simple answer.
Found [[https://www.amazon.com/Coding-Matrix-Algebra-Applications-Computer/dp/0615880991][this]] book look promising.

Beside math below code is very simple.
We only need to dot product rows of first to *column* of second because we only have one row it's sequence of numbers.

And we represent =(list 1 2 3)= as
\begin{bmatrix}
1 \\
2 \\
3 \\
\end{bmatrix}

We need to apply =(dot-product)=  on the list of rows.

=(map)= gives elements of list once at time, since elements of list are rows we can what we want.

#+begin_src racket :noweb eval
<<dot>>
(define (matrix-*-vector m v)
   (map (lambda (m-row) (dot-product m-row v))
        m))
#+end_src


#+name: mv
#+begin_src racket :tangle no :eval no :noweb eval
<<dot>>
<<rand-data>>
(define (matrix-*-vector m v)
  (if (not (= (length (car m))
              (length v)))
      #f ;; Can't multiply
      (map (lambda  (row)
             (dot-product row v))
           m)))
#+end_src

#+begin_src racket :noweb eval
<<mv>>
(matrix-*-vector m1 v1)
#+end_src

#+RESULTS:
: (14 32 50)

But output look like
\begin{bmatrix}
14 \\
32 \\
50 \\
\end{bmatrix}

TODO But should look like
\begin{bmatrix}
14 & 32 & 50
\end{bmatrix}


Just make the transition row-> column column->row.

Main idea is this

#+begin_src racket :noweb eval
<<dot>>
<<rand-data>>
(map car m1)
(map cadr m1)
(map caddr m1)
#+end_src

#+RESULTS:
: (1 4 7)
: (2 5 8)
: (3 6 9)
: #f

Problem with this is in last =(map cdr m)= new =m= become ='(nil nil nil)= and this is not null in means of
=(null?)=.

#+begin_src racket :noweb eval :eval no
(define (transpose m)
  (if (null? m)
      m
      
      (cons (map car m)
            (transpose (map cdr m)))))
(transpose m1)
#+end_src

We know that all rows same column so =(car m)= never will be number just null.
So we can take its =(cdr)= in consequent

#+begin_src racket :noweb eval
<<dot>>
<<rand-data>>
(define (transpose m)
  (if (null? (car m))
      (list)
      (cons (map car m)
            (transpose (map cdr m)))))

(transpose m1)
#+end_src

#+RESULTS:
: ((1 4 7) (2 5 8) (3 6 9))

This one has repeating parts we know that =(accumulate)= takes an operator, initial value and a list.
But we have nested lists so we need to use =(accumulate-n)=

#+name: trans
#+begin_src racket :noweb eval
<<dot>>
<<rand-data>>
(define (transpose m)
  (accumulate-n cons (list) m))
#+end_src


#+begin_src racket :noweb eval
<<trans>>

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map
     (lambda (row)
       (map (lambda (col)
              (dot-product row col))
            cols))
       m)))
#+end_src

But this doesn't fit question's format.
In previous part we handled that one column, and now we have multiple columns.
We can reuse previous =(matrix-*-vector)= but there is one problem.
Because we have only one column at a time we are writing one column of the product.
But it represented as a list.
It's like this.

First iteration

\begin{bmatrix}
x & _ & _ \\
x & _ & _ \\
x & _ & _ \\
\end{bmatrix}

Second

\begin{bmatrix}
x & y & _ \\
x & y & _ \\
x & y & _ \\
\end{bmatrix}

Last
\begin{bmatrix}
x & y & z \\
x & y & z \\
x & y & z \\
\end{bmatrix}

But in scheme it's like this
#+begin_src racket :tangle no :eval no
((x x x) (y y y) (z z z ))
#+end_src

So we need to transpose it.


#+begin_src racket :noweb eval
<<mv>>
(define (transpose m)
  (accumulate-n cons (list) m))

(define (matrix-*-matrix m n)
  (transpose
   (map
    (lambda (col)
      (matrix-*-vector m col))
    (transpose n))))

(matrix-*-matrix m1 m2)
#+end_src

#+RESULTS:
: ((9 12 15) (24 33 42) (39 54 69))
* 2.38
#+name: fold
#+begin_src racket :noweb eval
<<acc>>
(define fold-right accumulate)

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
#+end_src

#+begin_src racket :noweb no-export
<<fold>>
(fold-right / 1 (list 1 2 3))
#+end_src

#+RESULTS:
: 3/2

This expands like this

#+begin_src racket :tangle no :eval no
(/ 1
   (/ 2
      (/ 3
         1)))
#+end_src

#+begin_src racket :noweb eval
<<fold>>
(fold-left / 1 (list 1 2 3))
#+end_src

#+RESULTS:
: 1/6

This expands like this.
#+begin_src racket :tangle no :eval no
(/ (acc (cdr l)
        1))

(/
 (/ (acc (cdr l))
    2)
 1)

(/
 (/
  (/ (acc (cdr l)
          3))
  2)
 1)

(/
 (/
  (/ 1 3)
  2)
 1)
 #+end_src


#+begin_src racket :noweb eval
<<fold>>
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#+end_src

#+RESULTS:
: (1 (2 (3 ())))
: (((() 1) 2) 3)

=+= gives same value with both fold.
#+begin_src racket :noweb eval
<<fold>>
(fold-right + 0 (list 1 2 3))
(fold-left + 0 (list 1 2 3))
#+end_src

#+RESULTS:
: 6
: 6

Also I think below code is better explanation of =fold-left=
#+begin_src racket
(define (my/fold-left op initial seq)
  (if (null? seq)
      initial
      (op (my/fold-left op initial (cdr seq))
          (car seq))))

(my/fold-left / 1 (list 1 2 3))
#+end_src

#+RESULTS:
: 1/6
* 2.39
I learned that Scheme is [[https://stackoverflow.com/questions/4578574/what-is-the-difference-between-lisp-1-and-lisp-2][LISP 1]].
That's why there is no =()= around procedure names anymore.

With =fold-right=
#+begin_src racket :noweb no-export
<<fold>>
(define (reverse sequence)
  (fold-right (lambda (x y)
                    (append y (list x)))
              nil sequence))
(reverse (list 1 2 3))
#+end_src

#+RESULTS:
: (3 2 1)

With =fold-left=
I suggest you think through the recursive definition of =fold-left=.

#+begin_src racket :noweb eval
<<fold>>
(define (rev sequence)
  (fold-left (lambda (x y)
               (append (list y) x))
             nil sequence))

(rev (list 1 2 3))
#+end_src

#+RESULTS:
: (3 2 1)

Simple advice: Always imagine algorithm with 2 steps length.
To see initial value in action and see the whole structure of recursion.

=fold-right=
#+begin_src racket :tangle no :eval no
(reverse (list 1 2))

(op 1
    (op 2
        nil))
#+end_src

=fold-left=
#+begin_src racket :tangle no :eval no
(reverse (list 1 2))

(op (op nil
        2)
    1)
#+end_src
* TODO 2.44
Add instructions for racket.
#+begin_src racket :eval no
(#%require sicp-pict)

(define ei einstein)

(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))

(define (up-split painter n)
  (if (= n 0)
      painter
      (let
          ((smaller (up-split painter (- n 1))))
        (below painter
               (beside smaller
                       smaller)))))

(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))

(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
#+end_src
* 2.45
#+begin_src racket
(define (split op1 op2)
  (lambda (painter n)
    (let ((small
           ((split op1 op2)
            painter (dec n))))
      (if (= painter 0)
        painter
        (op1 painter
             (op2 small
                  small))))))

(define right-split (split beside below))
(define up-split (split below beside))
#+end_src
