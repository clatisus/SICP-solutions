# -*- org-export-babel-evaluate: nil -*-
#+TITLE: Solutions
#+PROPERTY: header-args:racket  :lang sicp :exports both
#+PROPERTY: header-args:racket+ :tangle (concat (nth 4 (org-heading-components)) ".rkt")

* Procedures
:PROPERTIES:
:header-args:racket: :tangle no :export none :eval never
:END:
** gcd
#+name: gcd
#+begin_src racket
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+end_src
** sqrt
#+name: sqrt
#+begin_src racket
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
#+end_src

#+RESULTS: sqrt

*** average-damp
#+name: average-damp
#+begin_src racket
(define (average-damp f)
  (lambda (x) (/ (+ (f x)
                    x)
                 2)))
#+end_src

** fixed-point
#+name: fixed-point
#+begin_src racket
(define (fixed-point f first-guess)
  (define tolerance 0.00001)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

#+end_src
** square
#+name: square
#+begin_src racket
(define (square x) (* x x))
#+end_src

* 2.01
In =(let*)= you can use previously defined local variable.

One argument =(-)= is =(lambda (x) (* -1 x)=
One argument =(+)= is =(lambda (x) (* 1 x)=
#+begin_src racket :noweb yes
<<gcd>>
<<rat>>
(define (make-rat n d)
  (let* ((neg ((if negative? d) - +))
         (n (abs n))
         (d (abs d))
         (g (gcd n d)))
    (cons (neg (/ n g))
          (/ d g))))
#+end_src
* 2.02
Point procedures
#+name: point
#+begin_src racket
(define (average x y) (/ (+ x y) 2))

(define (make-point x y)
  (cons x y))

(define (x-point p)
  (car p))

(define (y-point p)
  (cdr p))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
#+end_src

Segment procedures

#+name: segment
#+begin_src racket
(define (make-segment p1 p2)
  (cons p1 p2))

(define (start-segment p)
  (car p))

(define (end-segment p)
  (cdr p))

(define (midpoint-segment s)
  (make-point
   (average (x-point (start-segment s))
            (x-point (end-segment s)))
   (average (y-point (start-segment s))
            (y-point (end-segment s)))))
#+end_src

#+begin_src racket :noweb eval
<<point>>
<<segment>>
(define p1 (make-point 0 0))
(define p2 (make-point 10 10))

(define s (make-segment p1 p2))

(print-point (midpoint-segment s))
#+end_src

#+RESULTS:
:
: (5,5)

* 2.03
#+name: method-1
#+begin_src racket :noweb eval
<<point>>
<<segment>>
<<compose>>
<<square>>

(define (make-rect p1 p2 p3 p4)
  ;; p1 ----seg1----- p2
  ;;  |               |
  ;;  s               s
  ;;  e               e
  ;;  g               g
  ;;  3               4
  ;;  |               |
  ;; p3 ----seg2----- p4
  (cons (cons p1 p2)
        (cons p3 p4)))

(define (p1-rect r)
 (car (car r)))

(define (p2-rect r)
 (cdr (car r)))

(define (p3-rect r)
 (car (cdr r)))

(define (p4-rect r)
 (cdr (car r)))

(define (h-rect r)
  (distance (p1-rect r)
            (p3-rect r)))
(define (w-rect r)
  (distance (p1-rect r)
            (p2-rect r)))

(define (distance p1 p2)
  (sqrt
   (+ (square
       (- (x-point p1 ) (x-point p2)))
      (square
       (- (y-point p1 ) (y-point p2))))))

(define (perimiter-rect r)
  (* 2
     (+ (h-rect r)
        (w-rect r))))

(define (area-rect r)
  (* (h-rect r)
     (w-rect r)))
#+end_src

#+begin_src racket :noweb eval
<<method-1>>
(define p1 (make-point 0 4))
(define p2 (make-point 3 4))
(define p3 (make-point 0 0))
(define p4 (make-point 3 0))

(define r (make-rect p1 p2 p3 p4))

(perimiter-rect r)
(area-rect r)
r
#+end_src

#+RESULTS:
: 14
: 12

#+name: method-2
#+begin_src racket :noweb eval
<<point>>
<<segment>>
<<compose>>
<<square>>

(define (make-rect lb h w) ;; left-botton height widht
  (cons lb
        (cons h w)))

(define (h-rect r)
  (car (cdr r)))
(define (w-rect r)
  (cdr (cdr r)))

(define (perimiter-rect r)
  (* 2
     (+ (h-rect r)
        (w-rect r))))

(define (area-rect r)
  (* (h-rect r)
     (w-rect r)))
#+end_src

#+begin_src racket :noweb eval
<<method-2>>
(define p1 (make-point 0 0))
(define r (make-rect p1 4 3))

(perimiter-rect r)
(area-rect r)
#+end_src

#+RESULTS:
: 14
: 12
* 2.04
#+begin_src racket
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))

(car (cons 1 2))
#+end_src

#+RESULTS:
: 1

=(cons)= returns a procedure which takes one argument and applies other arguments as its
operand.

=(car)= Takes a [procedure] as argument and applies it to a lambda which returns its first argument.

#+begin_src racket :tangle no :eval no
(car (cons 1 2))
(car (lambda (m) (m 1 2)))
((lambda (m) (m 1 2) (lambda (p q) p)))
((lambda (p q) p) 1 2)
1
#+end_src

cdr
#+begin_src racket
(define (cons x y)
  (lambda (m) (m x y)))
(define (cdr z)
  (z (lambda (p q) q)))

(cdr (cons 1 2))
#+end_src

#+RESULTS:
: 2
* 2.05
#+begin_src racket
(define (cons a b)
  (* (expt 2 a)
     (expt b)))

(define (count base num)
  (if (= (remainder num base) 0)
      (+ 1 (count base(/ num base)))
      0))

(define (car p)
  (count 2 p))

(define (cdr p)
  (count 3 p))

(car (cons 5 9))
(cdr (cons 5 9))
#+end_src

#+RESULTS:
: 5
: 9
* TODO 2.06
I don't want to feel idiot about lambda calculus now.
I want to go through SICP.
TODO When I start lambda calculus solve this.
* 2.07
#+name: interval
#+begin_src racket
(define (make-interval a b) (cons a b))

(define (lower-bound i) (car i))
(define (upper-bound i) (cdr i))
#+end_src
* 2.08
#+begin_src racket :noweb no-export
<<interval>>
(define (sub-interval a b)
  (make-interval
   (- (lower-bound a) (lower-bound b))
   (- (upper-bound a) (upper-bound b))))
#+end_src
* 2.09
#+name: mul
#+begin_src racket :tangle no :eval no
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
#+end_src

#+name: add
#+begin_src racket :tangle no :eval no
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
#+end_src

In =(add-interval)= and =(sub-interval)= width of interval can be good parameter for finding new intervals width.
#+begin_src racket :noweb no-export
<<interval>>
<<mul>>
<<add>>

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define i1 (make-interval 10 20))
(define i2 (make-interval 30 50))

(width i1)
(width i2)
(width (add-interval i1 i2))
#+end_src

#+RESULTS:
: 5
: 10
: 15

But in =(mul-interval)= and =(div-interval)= something changes.
Functions must be give same output for same input.
If our input source don't contain enough, that operatoin won't be a =function=.
For example

Width of =(make-interval 0 10)= is 10 also width of =(make-interval 100 110)= is 10.
If we can create function like $f(w_1, w_2) = w_3$  $w_3$ should not differ with same inputs.
#+begin_src racket :noweb eval
<<interval>>
<<mul>>

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define i1 (make-interval 0 10))
(define i2 (make-interval 100 110))

(width i1)
(width i2)
(width (mul-interval i1 (make-interval 5 10)))
(width (mul-interval i2 (make-interval 5 10)))
#+end_src

#+RESULTS:
: 5
: 5
: 50
: 300
* 2.10
#+begin_src racket :noweb no-export
<<interval>>
<<mul>>

(define (div-interval x y)
  (if (or (zero? (upper-bound y))
          (zero? (lower-bound y)))
      (error "(div-interval x y) Y can't be 0")
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))

(div-interval (make-interval 10 20) (make-interval 0 10))
#+end_src

#+RESULTS:
: Errrrr
* TODO 2.11
These are the 9 conditions
Left ones have 1 2 right ones have a b

TODO Will add third column

| Interval 1 | Interval 2 |
| (+ . +)    | (+ . +)    |
|            |            |
| (- . -)    | (- . -)    |
|            |            |
| (- . -)    | (+ . +)    |
| (+ . +)    | (- . -)    |
|            |            |
| (- . +)    | (+ . +)    |
| (+ . +)    | (- . +)    |
|            |            |
| (- . +)    | (- . -)    |
| (- . -)    | (- . +)    |
|            |            |
| (- . +)    | (- . +)    |

Only last one needs more than 2 multiplication.

This will be very ugly If I wrote this with my narrow FP and DSL knowledge.
Lots of and , or ...
TODO When I learn pattern matching, simple macros etc will beauty up this.

#+begin_src racket :noweb eval :eval no :tangle no
<<interval>>

(define (I p1 p2))

(define (mul-interval a b)
  ((cond
     ((I ++ ++ a b) ....)
   )
  )
#+end_src
* 2.12
#+name: center
#+begin_src racket :noweb no-export
<<interval>>
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (make-center-percent c p)
  (make-interval (- c (/ (* c p) 100))
                 (+ c (/ (* c p) 100))))
(define (percent i)
  (/  (* 100 (width i)) (center i)))
#+end_src
* 2.13
To find something writing down equations.
We know that $p_1$ and $p_2$ are small.
To find lower bound of interval.
I  think we can say that (in ver small numbers)
\[\frac{c_1(100-p_1)}{100} \frac{c_2(100-p_2)}{100} \approx \frac{c_1c_2(10^4 - 100(p_1 + p_2) +p_1p_2)}{10^4}\]

$p_1p_2$ is multiplication of two small numbers to we can ignore it.

\[\frac{c_1c_2(10^2 -(p_1 + p_2))}{10^2}\]
Percent is $(1 -\frac{p_1 + p_2}{100}))$

We are talking about the little one. How much far from center.
So Percent is $p_1 + p_2$

#+begin_src racket :noweb no-export
<<center>>
<<mul>>


(percent (mul-interval (make-center-percent 10000 0.001)
              (make-center-percent 10000 0.001)))
(+ 0.001 0.001)

(percent (mul-interval (make-center-percent 100000000 0.00001)
              (make-center-percent 100000000 0.00001)))
(+ 0.00001 0.00001)
#+end_src

#+RESULTS:
: 0.001999999999807451
: 0.002
: 1.99999999999998e-05
: 2e-05

* 2.14
Trying to satisfy Lem E. Tweakit

#+name: div
#+begin_src racket :tangle no :eval no
(define (div-interval x y)
  (if (or (zero? (upper-bound y))
          (zero? (lower-bound y)))
      (error "(div-interval x y) Y can't be 0")
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))
#+end_src

They're really different
#+begin_src racket :noweb no-export
<<center>>
<<add>>
<<mul>>
<<div>>
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))

(define r1 (make-interval 10 20))
(define r2 (make-interval 10 20))

(par1 r1 r2)
(par2 r1 r2)
#+end_src

#+RESULTS:
: (2.5 . 20.0)
: (5.0 . 10.0)

With pen and paper it can be seen that =(par2)= gives true output.

#+name: p1
#+begin_src racket :noweb eval
<<center>>
<<add>>
<<mul>>
<<div>>
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define r1 (make-interval 10 20))
(define r2 (make-interval 10 20))

(par1 r1 r2) ;; 2.5 Wrong

(mul-interval r1 r2) ;; 100 True

(add-interval r1 r2);; 20 True

(div-interval ;; Should be 5 but 2.5
 (mul-interval r1 r2)
 (add-interval r1 r2))

;; (define (div-interval x y)
;;   (if (or (zero? (upper-bound y))
;;           (zero? (lower-bound y)))
;;       (error "(div-interval x y) Y can't be 0")
;;       (mul-interval
;;        x
;;        (make-interval (/ 1.0 (upper-bound y))
;;                       (/ 1.0 (lower-bound y))))))

(mul-interval (make-interval 100 400)
              (make-interval
               (/ 1.0 40)
               (/ 1.0 20)))

(* 100 (/ 1.0 40)) ;; This is the prolem
#+end_src
#+RESULTS:
: (2.5 . 20.0)
: (100 . 400)
: (20 . 40)
: (2.5 . 20.0)
: (2.5 . 20.0)
: 0.025
: 0.05

Because boundraies are changed in =(mul-divide)= values are changed too.
* 2.17
#+begin_src racket
(define (last-pair elements)
  (if (null? (cdr elements))
             elements
             (last-pair (cdr elements))))

(last-pair (list 1 2 3 4 5))
#+end_src

#+RESULTS:
: (5)
* 2.18
Iterative way

#+begin_src racket
(define (reverse elements)
  (define (iter l result)
    (if (null? l)
        result
        (iter (cdr l) (cons (car l) result))))
  (iter elements (list )))

(reverse (list 1 2 3))
#+end_src

#+RESULTS:
: (3 2 1)

Recursive way

This is wrong
#+begin_src racket :tangle no :eval no
(define (reverse l)
  (if (null? (cdr l))
      l
      (append (reverse (cdr l))
                       (car l))))

(reverse (list 1 2 3))
#+end_src

Because it expands like this last. Can see the problem in last line.

#+begin_src racket :tangle no :eval no
(append (reverse (list 2 3)) 1)
(append (append (reverse (list  3)) 2) 1)
(append (append (list 3) 2) 1)
(append (append (list 3) 2) 1)
#+end_src

When you append a atom to a a list it becomes pair because only difference between a pair and a list is
lists have =nil= at the end.
And you can =(append)= more to that pair because it'll never have =nil=.

#+begin_src racket :tangle no
(append (list 1 2 3) 2)
#+end_src

#+RESULTS:
: (1 2 3 . 2)

But that reverse will work for two pair because you don't need to =(append)= more.
#+begin_src racket
(define (reverse l)
  (if (null? (cdr l))
      l
      (append (reverse (cdr l))
                       (car l))))

(reverse (list 1 2))
#+end_src

#+RESULTS:
: (2 . 1)

For solution you need to =(append)= a list not an atom.
#+begin_src racket
(define (reverse l)
  (if (null? (cdr l))
      l
      (append (reverse (cdr l))
                       (list (car l)))))

(reverse (list 1 2 3 4))
#+end_src

#+RESULTS:
: (4 3 2 1)

In this
#+begin_src racket :tangle no :eval no
(append (reverse (list 2 3)) (list 1))
(append (append (reverse (list 3)) (list 2)) (list 1))
(append (append (list 3) (list 2)) (list 1))
(append (list 3 2) (list 1))
(append (list 3 2 1))
#+end_src

Difference between =(cons)= with this way you are creating same level pairs(lists).
So it won't nest up.
* 2.19
Order of coins should not effect result because tree will expand for every possible way.
#+begin_src racket
(define (cc amount coin-values)
  (define (no-more? l) (null? l))
  (define (except-first-denomination l) (cdr l))
  (define (first-denomination l) (car l))
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))

(define us-coins (list 50 25 10 5 1))
(define fake-us-coins (list 1 10 25 5 50))

(cc 100 us-coins)
(cc 100 fake-us-coins)
#+end_src

#+RESULTS:
: 292
: 292
: 104561
* TODO 2.20
Iterative way
#+begin_src racket
(define (same-parity base . l)
  (define (mod2 x) (remainder x 2))
  (define (iter l acc)
    (if (null? l)
        acc
        (iter (cdr l)
              (if (= (mod2 base) (mod2 (car l)))
                  (append acc (list (car l)))
                  acc))))
  (iter l (list base)))
#+end_src

Recursive way

#+begin_src racket
(define (same-parity base . l)
  (define (same? x)
    (= (remainder base 2)
       (remainder x 2)))

  (define (iter l)
    (if (null? (cdr l)) ;; Saved 1 call with cdr :)))
        l
        (append (if (same? (car l))
                    (list (car l))
                    (list))
                (iter (cdr l)))))
  (cons base (iter l)))
(same-parity 1 2 3 4 5 6 7)
#+end_src

#+RESULTS:
: (1 3 5 7)

This solution relies on the fact that you can append empty list without problem.

#+begin_src racket
(list 1 2 3 (list) 4 5 6)
(append (list 1 2 3) (list) (list 4 5 6))
#+end_src

#+RESULTS:
: (1 2 3 () 4 5 6)
: (1 2 3 4 5 6)

But using append is not very good for time complexity one should try to prepend with =(cons)= and =(reverse)= at the end.
But I don't know how to flatten the list so it's TODO.

* 2.21
#+name: sq
#+begin_src racket :tangle no :eval no
(define (square x) (* x x))
#+end_src

#+begin_src racket :noweb no-export
<<sq>>
(define (square-list items)
  (if (null? items)
      (list)
      (cons
       (square (car items)) (square-list (cdr items)))))


(define (square-list items)
  (map square items))

(square-list (list 1 2 3 4))
#+end_src
* 2.22
Problem is =answer= has the previous values why it's on right side.
#+begin_src racket :noweb no-export
<<sq>>
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))

(square-list (list 1 2 3))
#+end_src

#+RESULTS:
: (9 4 1)

In first =(cons)= probleem can seen. It evaluates this =(cons nil 1)=.
In second =(cons)= it evaluates =(cons (cons nil 1) 4)=
It nests up to handle this, can use =(append)=.
#+begin_src racket :noweb eval
<<sq>>
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))

(square-list (list 1 2 3))
#+end_src

#+RESULTS:
: (((() . 1) . 4) . 9)
* 2.23
#+begin_src racket
(define (for-each f l)
  (cond ((null? l) #t)
        (else
         (f (car l))
         (for-each f (cdr l)))))
#+end_src
