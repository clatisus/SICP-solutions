# -*- org-export-babel-evaluate: nil -*-
#+TITLE: Solutions
#+PROPERTY: header-args:racket  :lang sicp :exports both
#+PROPERTY: header-args:racket+ :tangle (concat (nth 4 (org-heading-components)) ".rkt")

* Procedures
:PROPERTIES:
:header-args:racket: :tangle no :export none :eval never
:END:
** gcd
#+name: gcd
#+begin_src racket
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+end_src
** sqrt
#+name: sqrt
#+begin_src racket
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
#+end_src

#+RESULTS: sqrt

*** average-damp
#+name: average-damp
#+begin_src racket
(define (average-damp f)
  (lambda (x) (/ (+ (f x)
                    x)
                 2)))
#+end_src

** fixed-point
#+name: fixed-point
#+begin_src racket
(define (fixed-point f first-guess)
  (define tolerance 0.00001)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

#+end_src
** square
#+name: square
#+begin_src racket
(define (square x) (* x x))
#+end_src

* 2.01
In =(let*)= you can use previously defined local variable.

One argument =(-)= is =(lambda (x) (* -1 x)=
One argument =(+)= is =(lambda (x) (* 1 x)=
#+begin_src racket :noweb yes
<<gcd>>
<<rat>>
(define (make-rat n d)
  (let* ((neg ((if negative? d) - +))
         (n (abs n))
         (d (abs d))
         (g (gcd n d)))
    (cons (neg (/ n g))
          (/ d g))))
#+end_src
